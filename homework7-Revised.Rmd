---
title: "Homework 7"
output:
  pdf_document: default
  html_document: default
Author: Aji John
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Problem 25 b


```{r,include=FALSE}
sim.a <- function(n=100,a=-2,b=1,c=pi/4)
{
  Zt <- rnorm(n+2)
  a + b*Zt[3:(n+2)] + c*Zt[1:n]
}

sim.b <- function(n=100,a=-3,b=1,c=pi/4)
{
  Zt <- rnorm(n+2,sd = sqrt(0.25))
  a + b*Zt[3:(n+2)] + c*Zt[1:n]
}

set.seed(42)

###
### source("http://faculty.washington.edu/dbp/s519/R-code/LD-recursions.R")
###
### given a vector acvf of length h+1 with values of an autocovariance
### function (theoretical or sample) at lags 0, 1, ..., h, the function
### LD.recursions runs the Levinson-Durbin recursions p times, where p is
### an integer less than or equal to h (if not supplied, p is set to h
### by default).  See below for an example of what this function returns
### (motivated by course overhead XI-24).

LD.recursions <- function(acvf, p=length(acvf)-1)
  {
    blpc <- vector(mode="list", length=p)
    phis <- acvf[2]/acvf[1]
    pev  <- rep(acvf[1],p+1)
    blpc[[1]] <- phis
    pacf <- rep(phis,p)
    pev[2] <- pev[1]*(1-phis^2)
    if(p > 1)
      {
        for(k in 2:p)
          {
            old.phis <- phis
            phis <- rep(0,k)
            ## compute kth order pacf (reflection coefficient)
            phis[k] <- (acvf[k+1] - sum(old.phis*acvf[k:2]))/pev[k]
            phis[1:(k-1)] <- old.phis - phis[k]*rev(old.phis)
            blpc[[k]] <- phis
            pacf[k]  <- phis[k]
            pev[k+1] <- pev[k]*(1-phis[k]^2)
          }
      }
    structure(list(coeffs=phis,innov.var=pev[p+1],pev=pev,pacf=pacf,blpc=blpc))
  }

innovations.algorithm <- function(acvf,n.max=length(acvf)-1)
  {
    thetas <- vector(mode="list",length=n.max)
    vs <- rep(acvf[1],n.max+1)
    for(n in 1:n.max)
      {
        thetas[[n]] <- rep(0,n)
        thetas[[n]][n] <- acvf[n+1]/vs[1]
        if(n>1)
          {
            for(k in 1:(n-1))
              {
                js <- 0:(k-1)
                thetas[[n]][n-k] <- (acvf[n-k+1] - sum(thetas[[k]][k-js]*thetas[[n]][n-js]*vs[js+1]))/vs[k+1]
              }
          }
        js <- 0:(n-1)
        vs[n+1] <- vs[n+1] - sum(thetas[[n]][n-js]^2*vs[js+1])
      }
    structure(list(vs=vs,thetas=thetas))
  }
```

## Problem 14 b

```{r,include=TRUE}

#Yt = 6/13 Yt−1 + Z2,t
AR1.acvf <- as.vector(ARMAacf(ar=c(6/13),ma=0,lag=4)) 
AR1.pacvf <- as.vector(ARMAacf(ar=c(6/13),ma=0,lag=4,pacf = TRUE))

print('LD')
print((results <- LD.recursions(AR1.acvf)))

par(mfrow=c(1,2))
plot(AR1.acvf,type = "h",xlab="lag")
abline(h=0)

plot(AR1.pacvf,type = "h",xlab="lag")
abline(h=0)
```

#innovations ar(1)
```{r,include=TRUE}

#Yt = 6/13 Yt−1 + Z2,t

print('innovations')
(results <- innovations.algorithm(AR1.acvf))

```

```{r,include=TRUE}

#Xt = Z1,t + 2/3Z1,t−1 (MA(1))
ma1.acvf <- as.vector(ARMAacf(ma=c(2/3),lag=4))
ma1.pacvf <- as.vector(ARMAacf(ma=c(2/3),lag=4,pacf = TRUE))
(results <- innovations.algorithm(ma1.acvf))

### > results$vs  # v_0, v_1, v_2, v_3
### [1] 1.777778 1.333333 1.000000 1.000000
### > results$thetas[[1]]  # theta_{1,1}
### [1] 0.5
### > results$thetas[[2]]  # theta_{2,1}, theta_{2,2}
### [1]  0.750 -0.125
### > results$thetas[[3]]  # theta_{3,1}, theta_{3,2}, theta_{3,3}
### [1]  0.75000  0.06250 -0.34375

par(mfrow=c(1,2))
plot(ma1.acvf,type = "h",xlab="lag")
abline(h=0)

plot(ma1.pacvf,type = "h",xlab="lag")
abline(h=0)
```

## Sample mean
```{r}

colMeans(acf.tss.mat.1000)

```
## Correlation Matrix
```{r}

knitr::kable(df_corr)

```

## Covariance Matrix
```{r}

knitr::kable(df_cov)

```





## Plot ENSO
```{r}


ENSO.ts <- scan("http://faculty.washington.edu/dbp/s519/Data/ENSO.txt")
StPaul.ENSO.times <- seq(1915+7/12,2009+2/12,1/12)
plot(StPaul.ENSO.times,ENSO.ts,typ="l",xlab="year",ylab=expression(x[t]),col="blue",main="ENSO Index")

ss.pacf <- acf(ENSO.ts, lag.max=40, type="partial", plot=FALSE)
xs <- 1:20
ys <- ss.pacf$acf[1:20]
plot(xs,ys,typ="h",xlab="h  (lag)",ylab="PACF",ylim=c(-1,1),col="blue",main="Sample PACF for ENSO Series")
points(xs,ys,col="red",cex=0.5)
n.ss <- length(ENSO.ts)
CI.hw <- 1.96/sqrt(n.ss)
abline(h=0,lty="dashed")
abline(h=c(-CI.hw,CI.hw),col="blue",lty="dashed")


#Slkide 12-10
```

We have PACF at lag 1,3 is out of 95% bounds, so it is not white noise.

